// Package {{.Package}} contém a implementação do repositório PostgreSQL para {{.StructName}}
// Code generated by pgx-goose with PostgreSQL templates. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"

	"github.com/fsvxavier/isis-golang-lib/db/postgresql"
	"github.com/fsvxavier/isis-golang-lib/db/postgresql/common"
)

// {{.StructName}}PostgreSQLRepository implementa {{.InterfaceName}} usando PostgreSQL
type {{.StructName}}PostgreSQLRepository struct {
	conn common.IConn
	pool common.IPool
}

// New{{.StructName}}PostgreSQLRepository cria uma nova instância do repositório PostgreSQL
func New{{.StructName}}PostgreSQLRepository(pool common.IPool) *{{.StructName}}PostgreSQLRepository {
	return &{{.StructName}}PostgreSQLRepository{
		pool: pool,
	}
}

// New{{.StructName}}PostgreSQLRepositoryWithConn cria uma nova instância do repositório PostgreSQL com conexão direta
func New{{.StructName}}PostgreSQLRepositoryWithConn(conn common.IConn) *{{.StructName}}PostgreSQLRepository {
	return &{{.StructName}}PostgreSQLRepository{
		conn: conn,
	}
}

// getConn retorna uma conexão, seja do pool ou direta
func (r *{{.StructName}}PostgreSQLRepository) getConn(ctx context.Context) (common.IConn, func(), error) {
	if r.conn != nil {
		return r.conn, func() {}, nil
	}
	
	conn, err := r.pool.Acquire(ctx)
	if err != nil {
		return nil, nil, err
	}
	
	return conn, func() { conn.Close(ctx) }, nil
}

// Create cria um novo registro
func (r *{{.StructName}}PostgreSQLRepository) Create(ctx context.Context, entity *{{.StructName}}) error {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `INSERT INTO {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} (
			{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}{{.Name}}{{$first = false}}{{end}}{{- end}}) 
	          VALUES (
			{{- $paramIndex := 1}}{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{- end}}) 
	          RETURNING {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}`

	args := []interface{}{
{{- range .Table.Columns}}
{{- if not .IsPrimaryKey}}
		entity.{{toPascalCase .Name}},
{{- end}}
{{- end}}
	}

	return conn.QueryOne(ctx, entity, query, args...)
}

// GetByID busca um registro por ID
func (r *{{.StructName}}PostgreSQLRepository) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*{{.StructName}}, error) {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return nil, fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}} FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} WHERE {{.PrimaryKeyCol}} = $1`

	var entity {{.StructName}}
	err = conn.QueryOne(ctx, &entity, query, id)
	if err != nil {
		if postgresql.IsEmptyResultError(err) {
			return nil, nil // Não encontrado
		}
		return nil, fmt.Errorf("erro ao buscar {{.StructName}} por ID: %w", err)
	}

	return &entity, nil
}

// Update atualiza um registro existente
func (r *{{.StructName}}PostgreSQLRepository) Update(ctx context.Context, entity *{{.StructName}}) error {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `UPDATE {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} 
	          SET {{$paramIndex := 2}}{{$first := true}}{{range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}{{.Name}} = ${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{end}}
	          WHERE {{.PrimaryKeyCol}} = $1 
	          RETURNING {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}`

	args := []interface{}{
		entity.{{.PrimaryKeyField}},
{{- range .Table.Columns}}
{{- if not .IsPrimaryKey}}
		entity.{{toPascalCase .Name}},
{{- end}}
{{- end}}
	}

	return conn.QueryOne(ctx, entity, query, args...)
}

// UpdatePartial atualiza campos específicos de um registro
func (r *{{.StructName}}PostgreSQLRepository) UpdatePartial(ctx context.Context, id {{.PrimaryKeyType}}, updates map[string]interface{}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("UpdatePartial não implementado ainda")
}

// Delete remove um registro permanentemente
func (r *{{.StructName}}PostgreSQLRepository) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `DELETE FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} WHERE {{.PrimaryKeyCol}} = $1`
	return conn.Exec(ctx, query, id)
}

// GetAll busca todos os registros com paginação
func (r *{{.StructName}}PostgreSQLRepository) GetAll(ctx context.Context, offset, limit int) ([]*{{.StructName}}, error) {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return nil, fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}} 
	          FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} 
	          ORDER BY {{.PrimaryKeyCol}} 
	          LIMIT $1 OFFSET $2`

	var entities []*{{.StructName}}
	err = conn.QueryAll(ctx, &entities, query, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("erro ao buscar todos os registros: %w", err)
	}

	return entities, nil
}

// Count retorna o total de registros
func (r *{{.StructName}}PostgreSQLRepository) Count(ctx context.Context) (int64, error) {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return 0, fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `SELECT COUNT(*) FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}}`
	
	count, err := conn.QueryCount(ctx, query)
	if err != nil {
		return 0, fmt.Errorf("erro ao contar registros: %w", err)
	}
	
	return int64(*count), nil
}

// Exists verifica se um registro existe
func (r *{{.StructName}}PostgreSQLRepository) Exists(ctx context.Context, id {{.PrimaryKeyType}}) (bool, error) {
	conn, release, err := r.getConn(ctx)
	if err != nil {
		return false, fmt.Errorf("erro ao obter conexão: %w", err)
	}
	defer release()

	query := `SELECT EXISTS(SELECT 1 FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} WHERE {{.PrimaryKeyCol}} = $1)`
	
	var exists bool
	row := conn.QueryRow(ctx, query, id)
	err = row.Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("erro ao verificar existência: %w", err)
	}

	return exists, nil
}

// FindBy busca registros com filtros personalizados
func (r *{{.StructName}}PostgreSQLRepository) FindBy(ctx context.Context, filters map[string]interface{}, offset, limit int) ([]*{{.StructName}}, error) {
	// Implementação básica - pode ser expandida
	return nil, fmt.Errorf("FindBy não implementado ainda")
}

// CountBy conta registros com filtros personalizados
func (r *{{.StructName}}PostgreSQLRepository) CountBy(ctx context.Context, filters map[string]interface{}) (int64, error) {
	// Implementação básica - pode ser expandida
	return 0, fmt.Errorf("CountBy não implementado ainda")
}

// CreateBatch cria múltiplos registros em lote
func (r *{{.StructName}}PostgreSQLRepository) CreateBatch(ctx context.Context, entities []*{{.StructName}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("CreateBatch não implementado ainda")
}

// CreateTx cria um novo registro usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) CreateTx(ctx context.Context, tx common.ITransaction, entity *{{.StructName}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("CreateTx não implementado ainda")
}

// UpdateTx atualiza um registro usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) UpdateTx(ctx context.Context, tx common.ITransaction, entity *{{.StructName}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("UpdateTx não implementado ainda")
}

// DeleteTx remove um registro usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) DeleteTx(ctx context.Context, tx common.ITransaction, id {{.PrimaryKeyType}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("DeleteTx não implementado ainda")
}

// CreateBatchTx cria múltiplos registros em lote usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) CreateBatchTx(ctx context.Context, tx common.ITransaction, entities []*{{.StructName}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("CreateBatchTx não implementado ainda")
}

// UpdateBatchTx atualiza múltiplos registros em lote usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) UpdateBatchTx(ctx context.Context, tx common.ITransaction, entities []*{{.StructName}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("UpdateBatchTx não implementado ainda")
}

// DeleteBatchTx remove múltiplos registros em lote usando uma transação
func (r *{{.StructName}}PostgreSQLRepository) DeleteBatchTx(ctx context.Context, tx common.ITransaction, ids []{{.PrimaryKeyType}}) error {
	// Implementação básica - pode ser expandida
	return fmt.Errorf("DeleteBatchTx não implementado ainda")
}
