// Package {{.Package}} contém os mocks para {{.InterfaceName}} usando testify
// Code generated by pgx-goose with PostgreSQL templates. DO NOT EDIT.
package {{.Package}}

import (
	"context"

	"github.com/fsvxavier/isis-golang-lib/db/postgresql/common"
	"github.com/stretchr/testify/mock"
)

// {{.MockName}} é um mock do {{.InterfaceName}} usando testify
type {{.MockName}} struct {
	mock.Mock
}

// NewMock{{.StructName}}Repository cria uma nova instância do mock
func NewMock{{.StructName}}Repository() *{{.MockName}} {
	return &{{.MockName}}{}
}

// Create mock para o método Create
func (m *{{.MockName}}) Create(ctx context.Context, entity *{{.StructName}}) error {
	args := m.Called(ctx, entity)
	return args.Error(0)
}

// CreateBatch mock para o método CreateBatch
func (m *{{.MockName}}) CreateBatch(ctx context.Context, entities []*{{.StructName}}) error {
	args := m.Called(ctx, entities)
	return args.Error(0)
}

// GetByID mock para o método GetByID
func (m *{{.MockName}}) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*{{.StructName}}, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*{{.StructName}}), args.Error(1)
}

// Update mock para o método Update
func (m *{{.MockName}}) Update(ctx context.Context, entity *{{.StructName}}) error {
	args := m.Called(ctx, entity)
	return args.Error(0)
}

// UpdatePartial mock para o método UpdatePartial
func (m *{{.MockName}}) UpdatePartial(ctx context.Context, id {{.PrimaryKeyType}}, updates map[string]interface{}) error {
	args := m.Called(ctx, id, updates)
	return args.Error(0)
}

// Delete mock para o método Delete
func (m *{{.MockName}}) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// GetAll mock para o método GetAll
func (m *{{.MockName}}) GetAll(ctx context.Context, offset, limit int) ([]*{{.StructName}}, error) {
	args := m.Called(ctx, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*{{.StructName}}), args.Error(1)
}

// Count mock para o método Count
func (m *{{.MockName}}) Count(ctx context.Context) (int64, error) {
	args := m.Called(ctx)
	return args.Get(0).(int64), args.Error(1)
}

// Exists mock para o método Exists
func (m *{{.MockName}}) Exists(ctx context.Context, id {{.PrimaryKeyType}}) (bool, error) {
	args := m.Called(ctx, id)
	return args.Bool(0), args.Error(1)
}

// FindBy mock para o método FindBy
func (m *{{.MockName}}) FindBy(ctx context.Context, filters map[string]interface{}, offset, limit int) ([]*{{.StructName}}, error) {
	args := m.Called(ctx, filters, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*{{.StructName}}), args.Error(1)
}

// CountBy mock para o método CountBy
func (m *{{.MockName}}) CountBy(ctx context.Context, filters map[string]interface{}) (int64, error) {
	args := m.Called(ctx, filters)
	return args.Get(0).(int64), args.Error(1)
}

// CreateTx mock para o método CreateTx
func (m *{{.MockName}}) CreateTx(ctx context.Context, tx common.ITransaction, entity *{{.StructName}}) error {
	args := m.Called(ctx, tx, entity)
	return args.Error(0)
}

// UpdateTx mock para o método UpdateTx
func (m *{{.MockName}}) UpdateTx(ctx context.Context, tx common.ITransaction, entity *{{.StructName}}) error {
	args := m.Called(ctx, tx, entity)
	return args.Error(0)
}

// DeleteTx mock para o método DeleteTx
func (m *{{.MockName}}) DeleteTx(ctx context.Context, tx common.ITransaction, id {{.PrimaryKeyType}}) error {
	args := m.Called(ctx, tx, id)
	return args.Error(0)
}

// CreateBatchTx mock para o método CreateBatchTx
func (m *{{.MockName}}) CreateBatchTx(ctx context.Context, tx common.ITransaction, entities []*{{.StructName}}) error {
	args := m.Called(ctx, tx, entities)
	return args.Error(0)
}

// UpdateBatchTx mock para o método UpdateBatchTx
func (m *{{.MockName}}) UpdateBatchTx(ctx context.Context, tx common.ITransaction, entities []*{{.StructName}}) error {
	args := m.Called(ctx, tx, entities)
	return args.Error(0)
}

// DeleteBatchTx mock para o método DeleteBatchTx
func (m *{{.MockName}}) DeleteBatchTx(ctx context.Context, tx common.ITransaction, ids []{{.PrimaryKeyType}}) error {
	args := m.Called(ctx, tx, ids)
	return args.Error(0)
}
