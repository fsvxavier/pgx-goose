// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	
	"github.com/fsvxavier/pgx-goose/models"
	"github.com/fsvxavier/pgx-goose/repository/interfaces"
)

// {{.ImplName}} implements the {{.InterfaceName}} interface
type {{.ImplName}} struct {
	db *pgxpool.Pool
}

// New{{.StructName}}Repository creates a new {{.StructName}} repository
func New{{.StructName}}Repository(db *pgxpool.Pool) interfaces.{{.InterfaceName}} {
	return &{{.ImplName}}{db: db}
}

// Create creates a new {{.StructName}}
func (r *{{.ImplName}}) Create(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	query := `
		INSERT INTO {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} (
			{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}{{.Name}}{{$first = false}}{{end}}{{- end}}
		) VALUES (
			{{- $paramIndex := 1}}{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{- end}}
		){{if .PrimaryKeyCol}} RETURNING {{.PrimaryKeyCol}}{{end}}
	`
	
	{{if .PrimaryKeyCol}}
	return r.db.QueryRow(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
	).Scan(&{{lower .StructName}}.{{toPascalCase .PrimaryKeyCol}})
	{{else}}
	_, err := r.db.Exec(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
	)
	return err
	{{end}}
}

// GetByID retrieves a {{.StructName}} by ID
func (r *{{.ImplName}}) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*models.{{.StructName}}, error) {
	query := `
		SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}
		FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}}
		WHERE {{.PrimaryKeyCol}} = $1
	`
	
	{{lower .StructName}} := &models.{{.StructName}}{}
	err := r.db.QueryRow(ctx, query, id).Scan(
		{{- range .Table.Columns}}
		&{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}
	)
	
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("{{lower .StructName}} with id %v not found", id)
		}
		return nil, err
	}
	
	return {{lower .StructName}}, nil
}

// Update updates an existing {{.StructName}}
func (r *{{.ImplName}}) Update(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	query := `
		UPDATE {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} SET
{{- $paramIndex := 1}}{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}
			{{.Name}} = ${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{- end}}
		WHERE {{.PrimaryKeyCol}} = ${{$paramIndex}}
	`
	
	_, err := r.db.Exec(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
		{{lower .StructName}}.{{toPascalCase .PrimaryKeyCol}},
	)
	
	return err
}

// Delete deletes a {{.StructName}} by ID
func (r *{{.ImplName}}) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	query := `DELETE FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}} WHERE {{.PrimaryKeyCol}} = $1`
	
	_, err := r.db.Exec(ctx, query, id)
	return err
}

// List retrieves all {{.StructName}}s with pagination
func (r *{{.ImplName}}) List(ctx context.Context, limit, offset int) ([]*models.{{.StructName}}, error) {
	query := `
		SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}
		FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}}
		ORDER BY {{.PrimaryKeyCol}}
		LIMIT $1 OFFSET $2
	`
	
	rows, err := r.db.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var {{lower .StructName}}s []*models.{{.StructName}}
	for rows.Next() {
		{{lower .StructName}} := &models.{{.StructName}}{}
		err := rows.Scan(
			{{- range .Table.Columns}}
			&{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}
		)
		if err != nil {
			return nil, err
		}
		{{lower .StructName}}s = append({{lower .StructName}}s, {{lower .StructName}})
	}
	
	return {{lower .StructName}}s, rows.Err()
}

// Count returns the total number of {{.StructName}}s
func (r *{{.ImplName}}) Count(ctx context.Context) (int64, error) {
	query := `SELECT COUNT(*) FROM {{if .Schema}}{{.Schema}}.{{end}}{{.Table.Name}}`
	
	var count int64
	err := r.db.QueryRow(ctx, query).Scan(&count)
	return count, err
}
