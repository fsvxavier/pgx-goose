package generator

import (
	"strings"
	"text/template"
)

// getEmbeddedTemplate returns embedded templates
func (g *Generator) getEmbeddedTemplate(name string) (*template.Template, error) {
	funcMap := template.FuncMap{
		"toPascalCase": toPascalCase,
		"lower":        strings.ToLower,
		"add": func(a, b int) int {
			return a + b
		},
		"slice": func(s string, start, end int) string {
			if start >= len(s) {
				return ""
			}
			if end > len(s) {
				end = len(s)
			}
			return s[start:end]
		},
	}

	switch name {
	case "model.tmpl":
		return template.New("model").Funcs(funcMap).Parse(modelTemplate)
	case "repository_interface.tmpl":
		return template.New("repository_interface").Funcs(funcMap).Parse(repositoryInterfaceTemplate)
	case "repository_postgres.tmpl":
		return template.New("repository_postgres").Funcs(funcMap).Parse(repositoryPostgresTemplate)
	case "mock_testify.tmpl":
		return template.New("mock_testify").Funcs(funcMap).Parse(mockTestifyTemplate)
	case "mock_gomock.tmpl":
		return template.New("mock_gomock").Funcs(funcMap).Parse(mockGomockTemplate)
	case "test.tmpl":
		return template.New("test").Funcs(funcMap).Parse(testTemplate)
	default:
		return nil, nil
	}
}

const modelTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"time"
	"encoding/json"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

{{if .Table.Comment}}// {{.StructName}} {{.Table.Comment}}{{end}}
type {{.StructName}} struct {
{{- range .Table.Columns}}
	{{toPascalCase .Name}} {{.GoType}} ` + "`json:\"{{.Name}},omitempty\" db:\"{{.Name}}\"`" + `{{if .Comment}} // {{.Comment}}{{end}}
{{- end}}
}

// TableName returns the table name
func ({{lower .StructName}}) TableName() string {
	return "{{.Table.Name}}"
}
`

const repositoryInterfaceTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	
	"github.com/fsvxavier/pgx-goose/models"
)

// {{.InterfaceName}} defines the interface for {{.StructName}} repository
type {{.InterfaceName}} interface {
	// Create creates a new {{.StructName}}
	Create(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error
	
	// GetByID retrieves a {{.StructName}} by ID
	GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*models.{{.StructName}}, error)
	
	// Update updates an existing {{.StructName}}
	Update(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error
	
	// Delete deletes a {{.StructName}} by ID
	Delete(ctx context.Context, id {{.PrimaryKeyType}}) error
	
	// List retrieves all {{.StructName}}s with pagination
	List(ctx context.Context, limit, offset int) ([]*models.{{.StructName}}, error)
	
	// Count returns the total number of {{.StructName}}s
	Count(ctx context.Context) (int64, error)
}
`

const repositoryPostgresTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	
	"github.com/fsvxavier/pgx-goose/models"
	"github.com/fsvxavier/pgx-goose/repository/interfaces"
)

// {{.ImplName}} implements the {{.InterfaceName}} interface
type {{.ImplName}} struct {
	db *pgxpool.Pool
}

// New{{.StructName}}Repository creates a new {{.StructName}} repository
func New{{.StructName}}Repository(db *pgxpool.Pool) interfaces.{{.InterfaceName}} {
	return &{{.ImplName}}{db: db}
}

// Create creates a new {{.StructName}}
func (r *{{.ImplName}}) Create(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	query := ` + "`" + `
		INSERT INTO {{.Table.Name}} (
			{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}{{.Name}}{{$first = false}}{{end}}{{- end}}
		) VALUES (
			{{- $paramIndex := 1}}{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{- end}}
		){{if .PrimaryKeyCol}} RETURNING {{.PrimaryKeyCol}}{{end}}
	` + "`" + `
	
	{{if .PrimaryKeyCol}}
	return r.db.QueryRow(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
	).Scan(&{{lower .StructName}}.{{toPascalCase .PrimaryKeyCol}})
	{{else}}
	_, err := r.db.Exec(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
	)
	return err
	{{end}}
}

// GetByID retrieves a {{.StructName}} by ID
func (r *{{.ImplName}}) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*models.{{.StructName}}, error) {
	query := ` + "`" + `
		SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}
		FROM {{.Table.Name}}
		WHERE {{.PrimaryKeyCol}} = $1
	` + "`" + `
	
	{{lower .StructName}} := &models.{{.StructName}}{}
	err := r.db.QueryRow(ctx, query, id).Scan(
		{{- range .Table.Columns}}
		&{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}
	)
	
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("{{lower .StructName}} with id %v not found", id)
		}
		return nil, err
	}
	
	return {{lower .StructName}}, nil
}

// Update updates an existing {{.StructName}}
func (r *{{.ImplName}}) Update(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	query := ` + "`" + `
		UPDATE {{.Table.Name}} SET
{{- $paramIndex := 1}}{{- $first := true}}{{- range .Table.Columns}}{{if not .IsPrimaryKey}}{{if not $first}}, {{end}}
			{{.Name}} = ${{$paramIndex}}{{$first = false}}{{$paramIndex = add $paramIndex 1}}{{end}}{{- end}}
		WHERE {{.PrimaryKeyCol}} = ${{$paramIndex}}
	` + "`" + `
	
	_, err := r.db.Exec(ctx, query,
		{{- range .Table.Columns}}{{if not .IsPrimaryKey}}
		{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}{{- end}}
		{{lower .StructName}}.{{toPascalCase .PrimaryKeyCol}},
	)
	
	return err
}

// Delete deletes a {{.StructName}} by ID
func (r *{{.ImplName}}) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	query := ` + "`DELETE FROM {{.Table.Name}} WHERE {{.PrimaryKeyCol}} = $1`" + `
	
	_, err := r.db.Exec(ctx, query, id)
	return err
}

// List retrieves all {{.StructName}}s with pagination
func (r *{{.ImplName}}) List(ctx context.Context, limit, offset int) ([]*models.{{.StructName}}, error) {
	query := ` + "`" + `
		SELECT {{range $i, $col := .Table.Columns}}{{if $i}}, {{end}}{{.Name}}{{end}}
		FROM {{.Table.Name}}
		ORDER BY {{.PrimaryKeyCol}}
		LIMIT $1 OFFSET $2
	` + "`" + `
	
	rows, err := r.db.Query(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var {{lower .StructName}}s []*models.{{.StructName}}
	for rows.Next() {
		{{lower .StructName}} := &models.{{.StructName}}{}
		err := rows.Scan(
			{{- range .Table.Columns}}
			&{{lower $.StructName}}.{{toPascalCase .Name}},{{end}}
		)
		if err != nil {
			return nil, err
		}
		{{lower .StructName}}s = append({{lower .StructName}}s, {{lower .StructName}})
	}
	
	return {{lower .StructName}}s, rows.Err()
}

// Count returns the total number of {{.StructName}}s
func (r *{{.ImplName}}) Count(ctx context.Context) (int64, error) {
	query := ` + "`SELECT COUNT(*) FROM {{.Table.Name}}`" + `
	
	var count int64
	err := r.db.QueryRow(ctx, query).Scan(&count)
	return count, err
}
`

const mockTestifyTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	
	"github.com/stretchr/testify/mock"
	
	"github.com/fsvxavier/pgx-goose/models"
	"github.com/fsvxavier/pgx-goose/repository/interfaces"
)

// {{.MockName}} is a mock implementation of {{.InterfaceName}}
type {{.MockName}} struct {
	mock.Mock
}

// Ensure {{.MockName}} implements {{.InterfaceName}}
var _ interfaces.{{.InterfaceName}} = (*{{.MockName}})(nil)

// Create mocks the Create method
func (m *{{.MockName}}) Create(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	args := m.Called(ctx, {{lower .StructName}})
	return args.Error(0)
}

// GetByID mocks the GetByID method
func (m *{{.MockName}}) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*models.{{.StructName}}, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*models.{{.StructName}}), args.Error(1)
}

// Update mocks the Update method
func (m *{{.MockName}}) Update(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	args := m.Called(ctx, {{lower .StructName}})
	return args.Error(0)
}

// Delete mocks the Delete method
func (m *{{.MockName}}) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// List mocks the List method
func (m *{{.MockName}}) List(ctx context.Context, limit, offset int) ([]*models.{{.StructName}}, error) {
	args := m.Called(ctx, limit, offset)
	return args.Get(0).([]*models.{{.StructName}}), args.Error(1)
}

// Count mocks the Count method
func (m *{{.MockName}}) Count(ctx context.Context) (int64, error) {
	args := m.Called(ctx)
	return args.Get(0).(int64), args.Error(1)
}
`

const mockGomockTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"reflect"

	"go.uber.org/mock/gomock"

	"github.com/fsvxavier/pgx-goose/models"
)

// {{.MockName}} is a mock of {{.InterfaceName}} interface.
type {{.MockName}} struct {
	ctrl     *gomock.Controller
	recorder *{{.MockName}}MockRecorder
}

// {{.MockName}}MockRecorder is the mock recorder for {{.MockName}}.
type {{.MockName}}MockRecorder struct {
	mock *{{.MockName}}
}

// New{{.MockName}} creates a new mock instance.
func New{{.MockName}}(ctrl *gomock.Controller) *{{.MockName}} {
	mock := &{{.MockName}}{ctrl: ctrl}
	mock.recorder = &{{.MockName}}MockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *{{.MockName}}) EXPECT() *{{.MockName}}MockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *{{.MockName}}) Count(ctx context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *{{.MockName}}MockRecorder) Count(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*{{.MockName}})(nil).Count), ctx)
}

// Create mocks base method.
func (m *{{.MockName}}) Create(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, {{lower .StructName}})
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *{{.MockName}}MockRecorder) Create(ctx, {{lower .StructName}} interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*{{.MockName}})(nil).Create), ctx, {{lower .StructName}})
}

// Delete mocks base method.
func (m *{{.MockName}}) Delete(ctx context.Context, id {{.PrimaryKeyType}}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *{{.MockName}}MockRecorder) Delete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*{{.MockName}})(nil).Delete), ctx, id)
}

// GetByID mocks base method.
func (m *{{.MockName}}) GetByID(ctx context.Context, id {{.PrimaryKeyType}}) (*models.{{.StructName}}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, id)
	ret0, _ := ret[0].(*models.{{.StructName}})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *{{.MockName}}MockRecorder) GetByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*{{.MockName}})(nil).GetByID), ctx, id)
}

// List mocks base method.
func (m *{{.MockName}}) List(ctx context.Context, limit, offset int) ([]*models.{{.StructName}}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, limit, offset)
	ret0, _ := ret[0].([]*models.{{.StructName}})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *{{.MockName}}MockRecorder) List(ctx, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*{{.MockName}})(nil).List), ctx, limit, offset)
}

// Update mocks base method.
func (m *{{.MockName}}) Update(ctx context.Context, {{lower .StructName}} *models.{{.StructName}}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, {{lower .StructName}})
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *{{.MockName}}MockRecorder) Update(ctx, {{lower .StructName}} interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*{{.MockName}})(nil).Update), ctx, {{lower .StructName}})
}
`

const testTemplate = `// Code generated by pgx-goose. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"testing"
	
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	
	"github.com/fsvxavier/pgx-goose/models"
	"github.com/fsvxavier/pgx-goose/mocks"
)

func Test{{.StructName}}Repository_Create(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	
	{{lower .StructName}} := &models.{{.StructName}}{
		// TODO: Set test data
	}
	
	t.Run("success", func(t *testing.T) {
		mock.On("Create", ctx, {{lower .StructName}}).Return(nil)
		
		err := mock.Create(ctx, {{lower .StructName}})
		
		assert.NoError(t, err)
		mock.AssertExpectations(t)
	})
	
	t.Run("error", func(t *testing.T) {
		mock.On("Create", ctx, {{lower .StructName}}).Return(assert.AnError)
		
		err := mock.Create(ctx, {{lower .StructName}})
		
		assert.Error(t, err)
		mock.AssertExpectations(t)
	})
}

func Test{{.StructName}}Repository_GetByID(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	id := {{.PrimaryKeyType}}(1) // TODO: Set appropriate test ID
	
	{{lower .StructName}} := &models.{{.StructName}}{
		// TODO: Set test data
	}
	
	t.Run("success", func(t *testing.T) {
		mock.On("GetByID", ctx, id).Return({{lower .StructName}}, nil)
		
		result, err := mock.GetByID(ctx, id)
		
		assert.NoError(t, err)
		assert.Equal(t, {{lower .StructName}}, result)
		mock.AssertExpectations(t)
	})
	
	t.Run("not found", func(t *testing.T) {
		mock.On("GetByID", ctx, id).Return((*models.{{.StructName}})(nil), assert.AnError)
		
		result, err := mock.GetByID(ctx, id)
		
		assert.Error(t, err)
		assert.Nil(t, result)
		mock.AssertExpectations(t)
	})
}

func Test{{.StructName}}Repository_Update(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	
	{{lower .StructName}} := &models.{{.StructName}}{
		// TODO: Set test data
	}
	
	t.Run("success", func(t *testing.T) {
		mock.On("Update", ctx, {{lower .StructName}}).Return(nil)
		
		err := mock.Update(ctx, {{lower .StructName}})
		
		assert.NoError(t, err)
		mock.AssertExpectations(t)
	})
	
	t.Run("error", func(t *testing.T) {
		mock.On("Update", ctx, {{lower .StructName}}).Return(assert.AnError)
		
		err := mock.Update(ctx, {{lower .StructName}})
		
		assert.Error(t, err)
		mock.AssertExpectations(t)
	})
}

func Test{{.StructName}}Repository_Delete(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	id := {{.PrimaryKeyType}}(1) // TODO: Set appropriate test ID
	
	t.Run("success", func(t *testing.T) {
		mock.On("Delete", ctx, id).Return(nil)
		
		err := mock.Delete(ctx, id)
		
		assert.NoError(t, err)
		mock.AssertExpectations(t)
	})
	
	t.Run("error", func(t *testing.T) {
		mock.On("Delete", ctx, id).Return(assert.AnError)
		
		err := mock.Delete(ctx, id)
		
		assert.Error(t, err)
		mock.AssertExpectations(t)
	})
}

func Test{{.StructName}}Repository_List(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	limit := 10
	offset := 0
	
	{{lower .StructName}}s := []*models.{{.StructName}}{
		// TODO: Set test data
	}
	
	t.Run("success", func(t *testing.T) {
		mock.On("List", ctx, limit, offset).Return({{lower .StructName}}s, nil)
		
		result, err := mock.List(ctx, limit, offset)
		
		assert.NoError(t, err)
		assert.Equal(t, {{lower .StructName}}s, result)
		mock.AssertExpectations(t)
	})
	
	t.Run("error", func(t *testing.T) {
		mock.On("List", ctx, limit, offset).Return([]*models.{{.StructName}}(nil), assert.AnError)
		
		result, err := mock.List(ctx, limit, offset)
		
		assert.Error(t, err)
		assert.Nil(t, result)
		mock.AssertExpectations(t)
	})
}

func Test{{.StructName}}Repository_Count(t *testing.T) {
	mock := &mocks.{{.MockName}}{}
	ctx := context.Background()
	expectedCount := int64(5)
	
	t.Run("success", func(t *testing.T) {
		mock.On("Count", ctx).Return(expectedCount, nil)
		
		count, err := mock.Count(ctx)
		
		assert.NoError(t, err)
		assert.Equal(t, expectedCount, count)
		mock.AssertExpectations(t)
	})
	
	t.Run("error", func(t *testing.T) {
		mock.On("Count", ctx).Return(int64(0), assert.AnError)
		
		count, err := mock.Count(ctx)
		
		assert.Error(t, err)
		assert.Equal(t, int64(0), count)
		mock.AssertExpectations(t)
	})
}
`
