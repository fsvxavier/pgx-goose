package generator

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"github.com/fsvxavier/pgx-goose/internal/config"
)

// GoGenerateIntegrator handles go:generate integration
type GoGenerateIntegrator struct {
	config *config.Config
}

// GenerateDirective represents a go:generate directive
type GenerateDirective struct {
	Package    string
	SourceFile string
	Command    string
	Args       []string
	OutputFile string
	Comment    string
}

// NewGoGenerateIntegrator creates a new go:generate integrator
func NewGoGenerateIntegrator(cfg *config.Config) *GoGenerateIntegrator {
	return &GoGenerateIntegrator{
		config: cfg,
	}
}

// GenerateDirectives generates go:generate directives for the project
func (ggi *GoGenerateIntegrator) GenerateDirectives() error {
	slog.Info("Generating go:generate directives")

	// Generate main generation directive
	if err := ggi.generateMainDirective(); err != nil {
		return fmt.Errorf("failed to generate main directive: %w", err)
	}

	// Generate model-specific directives
	if err := ggi.generateModelDirectives(); err != nil {
		return fmt.Errorf("failed to generate model directives: %w", err)
	}

	// Generate mock directives
	if err := ggi.generateMockDirectives(); err != nil {
		return fmt.Errorf("failed to generate mock directives: %w", err)
	}

	// Generate documentation directives
	if err := ggi.generateDocDirectives(); err != nil {
		return fmt.Errorf("failed to generate documentation directives: %w", err)
	}

	slog.Info("go:generate directives generated successfully")
	return nil
}

// generateMainDirective generates the main go:generate directive
func (ggi *GoGenerateIntegrator) generateMainDirective() error {
	// Create a generate.go file in the project root
	generateFile := filepath.Join(ggi.config.GetBaseDir(), "generate.go")

	content := ggi.buildMainGenerateFile()

	if err := os.WriteFile(generateFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write generate.go: %w", err)
	}

	slog.Info("Main generate.go file created", "path", generateFile)
	return nil
}

// buildMainGenerateFile builds the content for the main generate.go file
func (ggi *GoGenerateIntegrator) buildMainGenerateFile() string {
	packageName := ggi.getPackageName()
	configFile := ggi.getConfigFileReference()

	template := `// Code generated by pgx-goose. DO NOT EDIT.
// This file contains go:generate directives for automatic code generation.

//go:build ignore

package %s

// Generate all code from database schema
//go:generate pgx-goose --config %s

// Generate mocks for testing (requires mockgen)
//go:generate go run github.com/golang/mock/mockgen -source=repository/interfaces/user_repository.go -destination=mocks/user_repository_mock.go

// Generate documentation
//go:generate go run github.com/swaggo/swag/cmd/swag@latest init

// Generate SQL migrations from schema changes
//go:generate pgx-goose --config %s --generate-migrations

// Format generated code
//go:generate gofmt -w .

// Run tests to verify generated code
//go:generate go test ./...
`

	return fmt.Sprintf(template, packageName, configFile, configFile)
}

// generateModelDirectives generates go:generate directives for models
func (ggi *GoGenerateIntegrator) generateModelDirectives() error {
	modelsDir := ggi.config.GetModelsDir()

	// Create a models/generate.go file
	generateFile := filepath.Join(modelsDir, "generate.go")

	content := ggi.buildModelsGenerateFile()

	if err := os.MkdirAll(modelsDir, 0755); err != nil {
		return err
	}

	if err := os.WriteFile(generateFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write models/generate.go: %w", err)
	}

	slog.Info("Models generate.go file created", "path", generateFile)
	return nil
}

// buildModelsGenerateFile builds the content for models/generate.go
func (ggi *GoGenerateIntegrator) buildModelsGenerateFile() string {
	packageName := "models"
	configFile := ggi.getConfigFileReference()

	template := `// Code generated by pgx-goose. DO NOT EDIT.

//go:build ignore

package %s

// Generate models from database schema
//go:generate pgx-goose --config %s --models-only

// Generate JSON tags and validation
//go:generate go run github.com/mailru/easyjson/easyjson@latest -all .

// Generate string methods for enums
//go:generate go run golang.org/x/tools/cmd/stringer@latest -type=Status,UserRole

// Validate generated models
//go:generate go run github.com/go-playground/validator/v10/cmd/validator@latest .
`

	return fmt.Sprintf(template, packageName, configFile)
}

// generateMockDirectives generates go:generate directives for mocks
func (ggi *GoGenerateIntegrator) generateMockDirectives() error {
	interfacesDir := ggi.config.GetInterfacesDir()
	mocksDir := ggi.config.GetMocksDir()

	// Create a mocks/generate.go file
	generateFile := filepath.Join(mocksDir, "generate.go")

	content := ggi.buildMocksGenerateFile(interfacesDir)

	if err := os.MkdirAll(mocksDir, 0755); err != nil {
		return err
	}

	if err := os.WriteFile(generateFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write mocks/generate.go: %w", err)
	}

	slog.Info("Mocks generate.go file created", "path", generateFile)
	return nil
}

// buildMocksGenerateFile builds the content for mocks/generate.go
func (ggi *GoGenerateIntegrator) buildMocksGenerateFile(interfacesDir string) string {
	packageName := "mocks"
	relativeInterfacesDir := ggi.getRelativePath(interfacesDir)

	template := `// Code generated by pgx-goose. DO NOT EDIT.

//go:build ignore

package %s

// Generate mocks using mockgen
//go:generate go run github.com/golang/mock/mockgen -source=%s/user_repository.go -destination=user_repository_mock.go
//go:generate go run github.com/golang/mock/mockgen -source=%s/product_repository.go -destination=product_repository_mock.go

// Generate testify mocks
//go:generate go run github.com/vektra/mockery/v2@latest --dir=%s --all --output=.

// Format generated mocks
//go:generate gofmt -w .
`

	return fmt.Sprintf(template, packageName, relativeInterfacesDir, relativeInterfacesDir, relativeInterfacesDir)
}

// generateDocDirectives generates go:generate directives for documentation
func (ggi *GoGenerateIntegrator) generateDocDirectives() error {
	baseDir := ggi.config.GetBaseDir()

	// Create a docs/generate.go file
	docsDir := filepath.Join(baseDir, "docs")
	generateFile := filepath.Join(docsDir, "generate.go")

	content := ggi.buildDocsGenerateFile()

	if err := os.MkdirAll(docsDir, 0755); err != nil {
		return err
	}

	if err := os.WriteFile(generateFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write docs/generate.go: %w", err)
	}

	slog.Info("Docs generate.go file created", "path", generateFile)
	return nil
}

// buildDocsGenerateFile builds the content for docs/generate.go
func (ggi *GoGenerateIntegrator) buildDocsGenerateFile() string {
	template := `// Code generated by pgx-goose. DO NOT EDIT.

//go:build ignore

package docs

// Generate API documentation
//go:generate go run github.com/swaggo/swag/cmd/swag@latest init -g ../main.go -o .

// Generate database schema documentation
//go:generate pgx-goose --config ../pgx-goose-conf.yaml --generate-docs

// Generate Go documentation
//go:generate go run golang.org/x/tools/cmd/godoc@latest -http=:6060

// Generate README from templates
//go:generate go run github.com/robertkrimen/godocdown/godocdown@latest -o ../README.md ..
`

	return template
}

// GenerateMakefile generates a Makefile with go:generate integration
func (ggi *GoGenerateIntegrator) GenerateMakefile() error {
	makefilePath := filepath.Join(ggi.config.GetBaseDir(), "Makefile")

	content := ggi.buildMakefileContent()

	if err := os.WriteFile(makefilePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write Makefile: %w", err)
	}

	slog.Info("Makefile created", "path", makefilePath)
	return nil
}

// buildMakefileContent builds the content for the Makefile
func (ggi *GoGenerateIntegrator) buildMakefileContent() string {
	template := `.PHONY: generate clean build test lint format docs

# Default target
all: generate build test

# Generate all code from database schema
generate:
	go generate ./...

# Generate only models
generate-models:
	pgx-goose --config pgx-goose-conf.yaml --models-only

# Generate only mocks
generate-mocks:
	go generate ./mocks/

# Generate only documentation
generate-docs:
	go generate ./docs/

# Generate migrations from schema changes
generate-migrations:
	pgx-goose --config pgx-goose-conf.yaml --generate-migrations

# Clean generated files
clean:
	rm -rf models/ repository/ mocks/ tests/
	rm -f docs/*.md docs/*.json docs/*.yaml

# Build the application
build:
	go build -o bin/app ./cmd/

# Run tests
test:
	go test -v ./...

# Run tests with coverage
test-coverage:
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

# Lint code
lint:
	golangci-lint run ./...

# Format code
format:
	gofmt -w .
	goimports -w .

# Install dependencies
deps:
	go mod download
	go mod tidy

# Development setup
dev-setup: deps
	go install github.com/golang/mock/mockgen@latest
	go install github.com/swaggo/swag/cmd/swag@latest
	go install golang.org/x/tools/cmd/goimports@latest
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Database operations
db-migrate:
	goose -dir migrations postgres "$(DATABASE_URL)" up

db-rollback:
	goose -dir migrations postgres "$(DATABASE_URL)" down

# Full regeneration (clean + generate + test)
regenerate: clean generate test

# Watch for changes and regenerate
watch:
	find . -name "*.go" -o -name "*.yaml" -o -name "*.json" | entr -r make regenerate
`

	return template
}

// GenerateGitIgnore generates a .gitignore file for generated content
func (ggi *GoGenerateIntegrator) GenerateGitIgnore() error {
	gitignorePath := filepath.Join(ggi.config.GetBaseDir(), ".gitignore")

	// Check if .gitignore already exists
	var existingContent []byte
	if data, err := os.ReadFile(gitignorePath); err == nil {
		existingContent = data
	}

	// Generate our additions
	additions := ggi.buildGitIgnoreAdditions()

	// Check if our additions are already present
	existingStr := string(existingContent)
	if strings.Contains(existingStr, "# pgx-goose generated files") {
		slog.Info(".gitignore already contains pgx-goose entries")
		return nil
	}

	// Append our additions
	var content string
	if len(existingContent) > 0 {
		content = string(existingContent) + "\n\n" + additions
	} else {
		content = additions
	}

	if err := os.WriteFile(gitignorePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write .gitignore: %w", err)
	}

	slog.Info(".gitignore updated", "path", gitignorePath)
	return nil
}

// buildGitIgnoreAdditions builds additions for .gitignore
func (ggi *GoGenerateIntegrator) buildGitIgnoreAdditions() string {
	return `# pgx-goose generated files
# These files are automatically generated and should not be committed
**/generate.go
.pgx-goose-metadata.json
coverage.out
coverage.html

# Generated documentation
docs/*.md
docs/*.json
docs/*.yaml
docs/swagger.json
docs/swagger.yaml

# Temporary files
*.tmp
*.temp
.DS_Store
`
}

// GenerateVSCodeTasks generates VS Code tasks for go:generate
func (ggi *GoGenerateIntegrator) GenerateVSCodeTasks() error {
	vscodeDir := filepath.Join(ggi.config.GetBaseDir(), ".vscode")
	tasksFile := filepath.Join(vscodeDir, "tasks.json")

	if err := os.MkdirAll(vscodeDir, 0755); err != nil {
		return err
	}

	content := ggi.buildVSCodeTasksContent()

	if err := os.WriteFile(tasksFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write VS Code tasks: %w", err)
	}

	slog.Info("VS Code tasks.json created", "path", tasksFile)
	return nil
}

// buildVSCodeTasksContent builds the content for VS Code tasks.json
func (ggi *GoGenerateIntegrator) buildVSCodeTasksContent() string {
	return `{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "pgx-goose: Generate All",
            "type": "shell",
            "command": "go",
            "args": ["generate", "./..."],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": "$go"
        },
        {
            "label": "pgx-goose: Generate Models",
            "type": "shell",
            "command": "pgx-goose",
            "args": ["--config", "pgx-goose-conf.yaml", "--models-only"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            }
        },
        {
            "label": "pgx-goose: Generate Mocks",
            "type": "shell",
            "command": "go",
            "args": ["generate", "./mocks/"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            }
        },
        {
            "label": "pgx-goose: Clean and Regenerate",
            "type": "shell",
            "command": "make",
            "args": ["regenerate"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            }
        }
    ]
}`
}

// Helper methods

// getPackageName determines the package name for the project
func (ggi *GoGenerateIntegrator) getPackageName() string {
	// Try to determine from go.mod or use default
	return "main"
}

// getConfigFileReference gets the relative path to the config file
func (ggi *GoGenerateIntegrator) getConfigFileReference() string {
	// Look for existing config files
	configFiles := []string{
		"pgx-goose-conf.yaml",
		"pgx-goose-conf.yml",
		"pgx-goose-conf.json",
	}

	for _, file := range configFiles {
		if _, err := os.Stat(file); err == nil {
			return file
		}
	}

	// Default to YAML
	return "pgx-goose-conf.yaml"
}

// getRelativePath gets the relative path from base directory
func (ggi *GoGenerateIntegrator) getRelativePath(absolutePath string) string {
	baseDir := ggi.config.GetBaseDir()
	if rel, err := filepath.Rel(baseDir, absolutePath); err == nil {
		return rel
	}
	return absolutePath
}

// GenerateAllIntegrationFiles generates all go:generate integration files
func (ggi *GoGenerateIntegrator) GenerateAllIntegrationFiles() error {
	slog.Info("Generating all go:generate integration files")

	if err := ggi.GenerateDirectives(); err != nil {
		return err
	}

	if err := ggi.GenerateMakefile(); err != nil {
		return err
	}

	if err := ggi.GenerateGitIgnore(); err != nil {
		return err
	}

	if err := ggi.GenerateVSCodeTasks(); err != nil {
		return err
	}

	slog.Info("All go:generate integration files generated successfully")
	return nil
}
